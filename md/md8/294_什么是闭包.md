# 什么是闭包？

闭包是函数和其词法作用域的组合。

当一个函数在其定义的作用域之外被调用时，依然能够访问到它定义时所在的词法作用域中的变量，这种现象就叫做闭包。

换句话说，即使外部函数已经执行结束、栈内存被回收，但因为内部函数仍然引用了外部函数的变量，这些变量不会被销毁，从而形成闭包。

```js
function createCounter(){
    let count = 0; // 外部函数作用域中的变量
    return function (){
        count++;  // 内部函数引用了外部变量
        return count;
    }
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

* 这里 `createCounter` 执行结束后，本该销毁的 `count` 变量，因为被返回的函数引用住了，得以持续存在。

* `counter` 每次调用，都会操作同一个 `count`，这就是闭包的效果。

### 闭包形成条件

* 存在嵌套函数（内部函数引用外部函数变量）。
* 内部函数被外部引用（比如 return 出去或作为回调传递）。

### 闭包的优点

* 保持状态
  * 闭包可以让函数“记住”外部变量的值，即使外部函数已经执行结束。例如计数器、缓存数据等场景。
* 数据封装与私有化
  * 闭包可以模拟私有变量，防止被外部直接修改。

```js
function User(name){
    let _name = name;
    return {
        getName: () => _name,
        setName: (newName) => (_name = newName),
    };
}
const u = User("Tom");
console.log(u.getName()); // Tom
u.setName("Jerry");
console.log(u.getName()); // Jerry
```

* `_name` 只能通过暴露的方法访问，外部无法直接修改。

### 闭包的缺点

* 内存占用
  * 闭包会使得外部作用域变量长期驻留在内存中，容易导致内存泄漏。
  * 比如在 DOM 事件回调中不注意清理闭包引用，就可能使得 DOM 节点无法被 GC。

```js
function bindEvent(){
    const el = document.getElementById("btn");
    const bigData = new Array(100000).fill("xxx"); // 模拟大数据
    el.onclick = () => {
        console.log(bigData.length); // bigData 会一直占用内存
    }
}
bindEvent();
```

如果后续移除按钮没有解绑事件，`bigData` 永远不会被释放。

* 调试难度增加
  * 闭包层层嵌套时，不容易追踪变量来源，代码可读性变差。





































