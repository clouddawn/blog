# 什么是观察者模式？

* 观察者模式是指一个对象（被观察者 / Subject）维护一组依赖它的对象（观察者 / Observer），当它自身状态发生改变时，会主动通知所有观察者更新。

```js
class Subject {
    constructor(){
        this.observers = [];
    }
    addObserver(observer){
        this.observers.push(observer);
    }
    removeObserver(observer){
        this.observers = this.observers.filter(o => o !== observer);
    }
    notify(data){
        this.observers.forEach(o => o.updata(data));
    }
}

class Observer {
    constructor(name){
        this.name = name;
    }
    updata(data){
        console.log(`${this.name}收到通知：`,data);
    }
}

// 使用
const subject = new Subject();
const o1 = new Observer('观察者1');
const o2 = new Observer('观察者2');
subject.addObserver(o1);
subject.addObserver(o2);

subject.notify('数据更新');
// 输出：观察者1 收到通知：数据更新
// 输出：观察者2 收到通知：数据更新
```



## 和发布-订阅模式有什么区别？

* 观察者模式中，观察者直接订阅目标对象，目标对象直接触发回调。
* 而发布-订阅模式有一个【事件总线 / 中间件】作为消息调度中心，发布者和订阅者互不感知。

## 应用场景

* Vue2 响应式：`Dep` 作为依赖收集器，`Watcher` 作为观察者，`Object.defineProperty` 劫持数据变化后触发 `Dep.notify()` 通知所有观察者更新视图。
* DOM 事件监听：浏览器内部事件系统就是观察者模式，事件源作为被观察者，监听器作为观察者。
* 自定义事件总线（EventEmitter）：通过 `on/emit` 也能实现观察者模式。

## Vue2 响应式为什么能用观察者模式实现？

在 Vue2 中，每个响应式数据属性都对应一个 Dep 对象。

* 当渲染函数执行时，会触发 getter，Dep 收集依赖，把当前 Watcher 加入观察者列表。
* 当属性 set 时，Dep 执行 `notify()` ，所有观察者（Watcher）被调用，触发组件重新渲染。

这种设计就是典型的观察者模式：数据 => 视图的一对多关系。

## 优点

* 目标和观察者之间是松散耦合，方便扩展和维护。
* 支持广播机制，一个变化可以影响多个观察者。

## 缺点

* 如果观察者过多，通知开销大。
* 调试困难，难以跟踪是谁触发了更新。
* 容易导致内存泄漏（观察者未移除）。

























