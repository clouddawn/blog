# 如何实现全局请求缓存？

在项目中，一些接口（如用户信息、字典数据、配置项）需要做全局请求缓存，避免重复请求。

## 1. 封装全局缓存工具

```js
// utils/requestCache.ts
const cache = new Map<string, { data: any; expire: number }>();

export async function requestWithCache<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl = 60000 // 默认缓存 1 分钟
): Promise<T> {
  const now = Date.now();
  const cached = cache.get(key);

  // 命中缓存并且未过期
  if (cached && cached.expire > now) {
    return cached.data;
  }

  // 重新请求并更新缓存
  const data = await fetcher();
  cache.set(key, { data, expire: now + ttl });
  return data;
}

// 可以提供强制清除缓存的能力
export function clearCache(key: string) {
  cache.delete(key);
}
```

## 2. 在 Pinia Store 中使用缓存

```js
// stores/user.ts
import { defineStore } from "pinia";
import { requestWithCache } from "@/utils/requestCache";
import { getUserInfo } from "@/api/user";

export const useUserStore = defineStore("user", {
  state: () => ({
    user: null as any
  }),
  actions: {
    async fetchUser() {
      this.user = await requestWithCache("user-info", getUserInfo, 60000);
    },

    async refreshUser() {
      // 清掉缓存后重新请求
      clearCache("user-info");
      this.user = await requestWithCache("user-info", getUserInfo, 60000);
    }
  }
});
```

## 3. 在组件中访问数据

```html
<script setup lang="ts">
import { onMounted } from "vue";
import { useUserStore } from "@/stores/user";

const userStore = useUserStore();

onMounted(() => {
  if (!userStore.user) {
    userStore.fetchUser();
  }
});
</script>

<template>
  <div>
    <h2>欢迎回来，{{ userStore.user?.nickname }}</h2>
  </div>
</template>
```

## 优势总结

* 避免重复请求
  * 多个组件都依赖用户数据时，只会有一次真实的网络请求。
* 缓存过期机制
  * 通过 `ttl` 控制缓存有效期
* 全局共享
  * 所有组件访问 `useUserStore` 时拿到的是同一份缓存数据。



























