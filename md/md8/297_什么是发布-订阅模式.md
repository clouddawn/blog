# 发布-订阅模式

* 发布者（Publisher）把事件发送到事件中心。
* 订阅者（Subscriber）通过事件中心订阅感兴趣的事件。
* 事件中心负责分发消息给所有订阅者。

## 和观察者模式有什么区别？

* 观察者模式：被观察者直接维护观察者列表，自己通知观察者。
* 发布-订阅模式：事件中心作为中介，发布者和订阅者互不感知，更加解耦。

## 应用场景

* Node.js EventEmitter：`on` 订阅，`emit` 发布。
* 前端事件总线：Vue2 常见的 `$emit / $on`，或 Mitt 这种轻量库。
* 跨组件通信：兄弟组件之间通过 EventBus 解耦。
* 消息队列 / 日志系统：解耦生产者或消费者。

```js
class EventBus {
    constructor(){
        this.events = {}; // 存放事件和回调
    }
    // 订阅
    on(event, callback){
        if(!this.events[event]){
           this.events[event] = [];
        }
        this.events[event].push(callback);
    }
    // 发布
    emit(event, ...args){
        if(this.events[event]){
           this.events[event].forEach(cb => cb(...args));
        }
    }
    // 取消订阅
    off(event, callback){
        if(!this.events[event]) return;
        this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
    // 只监听一次
    once(event, callback){
        const fn = (...grgs) => {
            callback(...agrs);
            this.off(event, fn);
        }
        this.on(event,fn);
    }
}

// 使用
const bus = new EventBus();
function log(msg){
    console.log('收到：', msg);
}

bus.on('test', log);
bus.emit('test', 'Hello Pub-Sub!'); // 收到：Hello Pub-Sub!
bus.off('test', log);
bus.emit('test', '不会再触发');
```

## 为什么要用发布-订阅模式，而不是直接调用函数？

直接调用函数意味着发布者必须知道订阅者是谁，这会导致模块间强耦合。

发布-订阅模式的优势是：

* 发布者和订阅者完全解耦，互不感知。
* 订阅者可以在运行时灵活增删。
* 支持广播，一个事件可以通知多个订阅者。
* 支持异步处理，适合日志系统、消息队列等场景。

## 缺点

* 调试困难：消息通过事件中心传递，不容易跟踪调用链。
* 性能开销：大量事件订阅/触发时，可能影响性能。
* 内存泄漏风险：订阅未取消，事件中心保存了无用的引用。





























